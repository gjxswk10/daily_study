[TOC]



# 2025年日志汇总

## 2025-04-08

## 开发九野个人版踩坑记录

## 一、网络匹配参考

主要参考这个网址：https://developer.unity.cn/projects/67d299e1edbc2a2b119bb6de

框架：multiverse+netcode+matchmaking，协议websocket/kcp

目前已全部跑通，接下来在这基础上开发九野。

*** 微信端开发工具的APPID，注意，小程序和小游戏是不一样的

### 1. 解决中文字符问题

#### 1.1 查找并复制中文字体

windows： 进入文件C:\windows\Fonts

选择其中一个字体，比如“楷体 常规”，复制进入项目的Assests/Resources/Fonts目录下。

![查找系统中文字体](.\photo\查找中文字符.png)

#### 1.2 生成TextMeshPro字符集

右键点击刚加入的字体文件，选择“Create->TextMeshPro->FontAssest”生成。

![生成Unity字符集](.\photo\生成UnityTextMeshPro字符集.png)

#### 1.3 使用中文字体

在需要使用中文字体的地方，将Font Asset设置为刚刚生成的字体。

![使用中文字体](.\photo\在使用处使用中文字符.png)



## 2025-04-09

### 一、加入Git版本管理

一开始直接在大项目下git init，结果数据太大很难跑通，实际上只要加入

* Assests/
* ProjectSettings/

这两上文件夹的版本管理即可。目前我是这样做的（网上介绍，这样最简），后续看会不会有其他影响。

## 2025-04-10

### 一、调通1v1 matchmaking模式

查找一天bug，未果

## 2025-04-12

### 一、调通1v1 matchmaking的问题



***解决方法：使用websocket代替kcp***

分析：不知道是不是因为kcp在底层使用udp的原因，导致之前基于示例教程中使用1v1 matchmaking进行匹配总是出bug，现象是：能够匹配成功，但在客户端却不绘制玩家预制体。

今天又调试查找了一天，能定位到错误出现在StartClient()这里，服务器能正确建立，客户端也能正确获得服务器的ip及端口，但就是不能建立起连接。

然后没有办法，想着试试websocket吧，结果一遍就过了。看来确实是kcp协议的问题，查了下，kcp底层一般是udp，它本身是一个中间层协议，并不处理底层网络协议，用户要自己定义底层的发送方式，并且通过回调传递给KCP。可能就是这个原因导致的吧。

之前想用KCP的原因是它快，且跟微信小游戏适配更好，现在看来可能需要额外配置一些东西才能使KCP协议在这里工作。

好吧，总算搞定这个问题了，快三天了吧！！！

### 二、客户端权威 or 服务器权威

在考虑这个问题，Unity 3D没有现成的客户端权威代码，在学的示例也是服务器权威的。但感觉客户端权威更符合我的需求，但可能需要更多的改动，目前尚在权衡。

后边想了想，暂时不纠结这个问题，先把本地资源和场景布局做好，之后需要服务器同步的资源再丢给服务器，其他就在本地计算。

看了下九野的日志，可以明确确定是“帧同步”的写法。

## 2025-04-13

### 一、重构九野资源

找到了之前做的Test Bundle程序，重新加载了九野的3D模型，用Instantiate可以恢复大部分数据，但无法处理Texture2D类型，导致加载的3D人物模型丢失纹理。尝试了一些方法，无果。无法完全还原带纹理的3D模型。

看到了Unity 3D新出现的工具Addressables，打算用新工具尝试一下，看看能不能完全还原人物模型。

## 2025-04-17

## 一、折腾Addressables

折腾了这些天的Addressables，以为能直接用它来正确、完整地加载AssetBundle文件，完美还原所有模型和依赖关系，结果今晚才发现：不能！！！它还是要用AssetBundle自身的API来进行加载。好吧，白忙活这些天了。

以后要加快文档阅读速度，提高效率，抓住重点，避免浪费无意义的时间。



## 2025-04-18

### 一、重新思考AssetBundle正确加载模型的问题

做了以下尝试：

* 重试了异步写法（于本次目标而言无关紧要，只是为了长远做准备）；
* 尝试了预加载，先加载Material、Texture2D，再加载类型，失败；
* 学习B站Up主LC_ilmlp关于Shader、MonoBehaviour的读取；
* 重新分析Card_284_001.ab结构，分析各个MonoBehaviour间的关系；
* 确定Card_284_001.ab中包含Manifest清单，最终找到files/dat文件下的总Manifest文件；
* 初步分析Manifest中给出的依赖项。

## 2025-04-19

### 一、尝试加载card_284_001

经过昨天的工作，已经能够正确加载出依赖项。在此基础上，找到了所有card_284_001模型的依赖项，但尝试加载时发现，某些依赖项，资源包里并没有，目前在这里卡住了。

尝试直接加载card_284_001，以为里边标为card/card_284_001.dat的文件是一个AssetBundleManifest文件。然而尝试之后发现，并不是。



## 2025-04-20

### 一、继续尝试加载九野模型

记录一下Unity模型不可见的常见原因，摘抄自（https://blog.csdn.net/qq_33060405/article/details/146927885）:

```
模型不可见：
模型不可见问题概述
在 Unity 中，模型不可见 是一个常见的问题，通常发生在使用 AssetBundle 加载 3D 模型时。如果模型的 AssetBundle 未加载，或者模型依赖的材质或贴图未加载，模型将无法在场景中正确显示。这不仅影响游戏的视觉效果，还可能影响玩家的体验。

常见原因
1. AssetBundle 未加载：

如果包含模型的 AssetBundle 没有成功加载，模型自然无法显示。
依赖的材质或贴图未加载：

2. 模型通常依赖于材质和贴图。如果这些资源未加载，模型可能会显示为不可见或使用默认材质。
3. 资源路径错误：

加载 AssetBundle 或模型时，如果指定的路径不正确，Unity 将无法找到并加载相应的资源。
4. 模型的缩放或位置问题：

模型的缩放设置为零或位置在摄像机视野之外，也会导致模型不可见。
渲染层级问题：

5. 模型可能被其他对象遮挡，或者其渲染层级设置不正确，导致无法在场景中显示。
6. Shader 问题：

如果模型使用的材质的 Shader 不支持当前的渲染管线，可能会导致模型不可见。
```

思路：尝试忽略掉缺失的前置资源，加载完其他前置资源后，直接加载card_284_001。在这里遇到新的问题：

* 由于原资源文件是加密的，所以想写一个将.dat转化为.ab的内存转换，但使用LoadFromMemoryAsync方法没成功，查看转换开头，确实是"Unity Fs"字样，目前不知道问题出在哪里？

## 2025-04-21

### 一、恢复九野3D模型

终于搞定！！！

***原来原因出在shader渲染出错上！我导入的是手机游戏的资源，渲染应该用OpenGL；但在重现工程时，电脑windows系统默认使用的渲染API是Direct3D***

经过以下步骤可以完美展现Card 284 模型。

* Edit -> Project Settings -> Player -> Other Settings，在确保程序没有运行时，去掉“Auto Graphics API for Windows"选项
* 在Graphics APIs for Windows中，添加OpenGLES3，并将其置于首位；或者将Direct3D11删掉均可。

![九野284号模型重现图](./photo/九野重构渲染API设置.png)



## 2025-04-22

### 一、反编译C#脚本文件

昨天试着加载初始界面和对战等场景，但仍有一堆元素无法显示（显示洋葱紫色），试了下也不是Shader渲染的原因。想到几种方法可以继续尝试：

* 缓存文件Cache中有其他Shader的缓存文件，是不是跟这个有关；
* 反编译C#脚本，如果可以，可以试试从底层一步步重构；
* dat->PAK文件夹下，有一堆PAK文件，经查是系统资源类的压缩文件，但使用压缩软件，或者AssetBundle等方式均无法打开，应当是需要特定脚本打开，因此尝试还原脚本反编译是必要的。

排除思路1：

```
‌ShaderCache文件‌在Unity中用于存储预编译的Shader数据。当你在Unity中导入Shader资源时，Unity会对Shader文件进行预编译，并将编译后的数据缓存到Library\ShaderCache目录下。这些缓存数据被称为Shader Compilation Info，它们是中间状态的数据，用于在运行时动态编译和处理Shader‌
1。
ShaderCache的作用和重要性
‌缓存预编译数据‌：ShaderCache存储了Shader的预编译数据，这些数据在运行时可以直接使用，减少了每次运行时的编译时间，提高了游戏或应用的加载速度和运行效率。
‌跨平台支持‌：ShaderLab工作流确保了Shader可以在不同的图形API（如DirectX、OpenGL和Vulkan）上正确编译和运行。通过预编译和缓存机制，Unity能够生成适用于目标平台的Shader资源，从而实现跨平台开发‌
1。
如何管理和优化ShaderCache
‌清理缓存‌：随着项目的更新和迭代，旧的Shader缓存可能会占用大量磁盘空间。可以通过Unity编辑器的菜单选项手动清理ShaderCache。在Windows系统上，可以在项目设置中找到玩家设置，然后选择其他设置，最后选择清理缓存选项。在Mac系统上，可以在构建设置中找到清理缓存的选项‌
1。
‌动态加载‌：在打包过程中，Unity可以对Shader进行Strip处理，特别是对于动态加载的Shader，需要小心处理以避免运行时错误。动态加载的Shader需要在运行时确保其正确加载和编译‌
```

搜索了下，PAK文件貌似不是UE4的打包文件，跟它的描述不符（当然，还不能完全排除）。可能是Quake生成的PAK文件，目前卡在这，想办法把PAK文件中的资源提取出来。



## 2025-04-23

### 一、尝试获取PAK文件中的资源

用其他方法尝试打开PAK文件：

* 感觉九野中的PAK文件是UE4生成的，在这个假定上，尝试了UnrealEnginePAKViewer，一通捣腾尝试之后，发现是要用源码编译生成UE4后，再去编译，得到PAKViewer的运行文件。由于用源码编译需要的究竟太大（网上说是100多个G），目前剩余空间不够，遂放弃。
* 使用命令行工具：UnrealPak.exe，尝试一番后，虽然没有报错，但也始终没有得到正确的输出文件。（目前还是无法确定PAK是否由UE4生成）

换个思路，先去反编译代码，看能不能反过来得到PAK文件的解构线索。于是了解了一下il2cpp是什么。

明天的思路：

1. 可以先试试在UE4中自己打包一个PAK文件，看看是否和九野文件相似，以此来确定PAK文件是否由UE4生成。
2. 反编译代码。

## 2025-04-24

### 一、在UE4中打包Android应用

沿着昨天的第一个思路，在UE4编辑器中，打包PAK文件，以对比九野文件。

先尝试了打包成Windows压缩PAK文件，发现格式有出入。

然后尝试打包成Android PAK文件，发现有三种压缩格式，另外还需要在UE4上配置Android开发环境，目前在捣腾这个地方。

## 2025-05-03

### 一、完成UE4中打包Android应用的任务

#### 1. 初步配置UE4的Android SDK和NDK环境

参考文档1：https://dev.epicgames.com/documentation/en-us/unreal-engine/setting-up-android-sdk-and-ndk-for-unreal?application_version=4.27

该文档详细介绍了UE 4.27打包Android应用的步骤。之所以先用4.27这个版本，是因为我能确定，九野如果使用了UE资源，那么肯定是在UE4中构建的，因为那时候UE5还没有面世。为了避免使用UE5造成相关资源的不兼容，所以先用UE4.27来完成任务。

按照该文档的说明，一步步进行下去，由于文档推荐使用默认地址，但我安装的相关资源（Android SDK、Android Studio、JDK等）都使用的非默认，所以在这块花了一些时间，调整了一些系统参数，最终成功运行“SetupAndroid.bat”，安装了NDK 21。

#### 2. 开通外网VPN

本以为可以成功了，但出现了下载gradle-6.1.1-all.zip错误，网上说可以直接下载好了放到指定目录，但该网址需要外网访问权限。无奈之下，在大搬家后，开了外网。

一开始想用之前一直用的hash云上网VPN，但重新搜了下，发现原服务网址已经关闭了。无奈之下，转试其他VPN，这里踩了一下坑：因为没弄清楚加速器和外网VPN的关系，给轻蜂加速器冲了38元，结果发现仍无法连接外网（但它的描述里有说外网加速，我就是被这描述给骗了）。

然后，搜了下ExpressVPN、ShadowSocks等以前见过的VPN软件，但看了下价格和描述，没有尝试下去。

发现“快连VPN”，还带免费体验一段时间，果断尝试了一下，真得可以上外网了，看了下价格，其实还算合理，但比我以前用的Hash云，稍微贵了些。

转头又搜索了下“Hash云”，点了下前几个链接深入了解后，才发现，“Hash云”已经改名叫“深蓝云”了，又看到了熟悉的界面，最终又重新使用了该服务，搞定VPN的问题。



#### 3. 版本兼容问题

搞定外网问题后，也顺利解决了“gradle”的下载问题，但使用UE4导出Android应用时，仍旧出现bug："armv7 java头无法识别"等字样，一开始我便推测可能是哪里的兼容出了问题，毕竟我使用的是较新版本的Android Studio meerkat 2024，默认SDK版本较高。但对于如何解决该问题，我没啥头绪。

幸好，今天下午搜到了一篇文章，解决了该问题：

文档2： https://blog.csdn.net/weixin_44090328/article/details/145865286

原来是要卸载掉原来的SDK，搭配所有适配的配置，当然，并不需要更改Android Studio自身的版本。

依照该文档的做法，并将Android/sdk下相关的Android 35（默认的Android SDK版本）残留文件清除。清除C:\Users\gejx2\\.android下的"debug.*"文件。再安装Java 8（原先使用最新的LTS版本Java 21，但仍失败报错，必须使用Java 8），将系统路径JAVA_HOME、PATH设置到Java 8的路径，并在Android Studio中配置gradle默认使用的JDK，设置UE 4.27中Android SDK路径。

以上全部设置好后，便可以打包成功了。



### 二、UE4中打包PAK文件

之前以为打包PAK文件与打包Android应用是一个意思，所以之前折腾的都是打包成Android，绕了远路。今晚，使用UnrealPak.exe工具，打包了一个PAK文件出来，与九野PAK文件对比了一下。你别说，长得还真得挺像的，除了开头没有"PAK"字样外，后边二者长得很像。

推测“PAK”字样也是类似的加密手段。